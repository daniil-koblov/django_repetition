# Данный репозиторий включает в себя повторение курса "Фреймворк Django" по программе
# обучения "Разработчик — Веб-разработка на Python. Технологическая специализация"
# образовательной платформы "GeekBrains".

## Урок 1. Введение в Django.

### Установка django

Перед установкой сначала нужно создать и активировать виртуальное окружение:

- Создание окружения

    - python -m venv venv — для Windows;
    - python3 -m venv venv — для Linux и MacOS.

- Активация окружения

    - venv\Scripts\activate — для Windows;
    - source venv/bin/activate — для Linux и MacOS.

- Выход из окружения

    - deactivate

После создания виртуальной среду надо установить сам django
предварительно установив еще библиотеку requests и после установок 
зафиксировать список библиотек и версий в файле *"requirements.txt"*:

- pip install requests
- pip install django
- pip freeze
- pip freeze > requirements.txt
- more requirements.txt - это для просмотра списка установленных библиотек. 

### Создание проекта

Для создания проекта сначала нужно перейти в каталог с виртуальным окружением
(venv) и запустить команду:

- django-admin startproject "myproject" 

Название "myproject" вводить без кавычек и само название можно придумать любое.

#### Структура корневого каталога проекта

- myproject/
    - manage.py
    - myproject/
      - __init__.py
      - settings.py
      - urls.py
      - asgi.py
      - wsgi.py

За что отвечает каждый файл:

- manage.py - файл, который используется для управления проектом. С его
помощью можно запустить сервер, создать миграции, создать
суперпользователя и т.д.

- myproject/ - директория, которая содержит основные файлы проекта.

- __init__.py - файл, который сообщает Python, что директория myproject
является пакетом.

- settings.py - файл, который содержит настройки проекта, такие как базы
данных, шаблоны, статические файлы и т.д.

- urls.py - файл, который содержит маршруты приложения.

- asgi.py - файл, который используется для запуска проекта 
в ASGI-совместимых серверах.

- wsgi.py - файл, который используется для запуска проекта 
в WSGI-совместимых серверах.

#### Запуск и проверка работоспособности проекта

Перед запуском надо перейти в каталог прокета, где находится файл 
*"manage.py"* и запустить команду:

- python manage.py runserver

После запуска вернется информация с адресом встроенного сервера
*"http://127.0.0.1:8000/"*.

В файле *"setting.py"* есть строка отладки. Перед запуском проекта в продакшен 
надо будет поменять настройку "DEBUG = True" на "DEBUG = False" 
чтобы отключить режим отладки.

Также в файле *"setting.py"* есть строки в которые заносятся IP-адреса
устройств, которые по локальной сети могут 
подключиться к активированному серверу.

*"ALLOWED_HOSTS = ['127.0.0.1', '192.168.1.47',]"*

### Создание приложения

Для создания приложения надо выполнить команду (также находясь в 
каталоге с файлом *"manage.py"*):

- python manage.py startapp "myapp"

Название "myapp" приложения так же как и с названием проекта указывается без
кавычек и может быть любым.

#### После создание приложение каталог проекта выглядит так:

- myproject/
    - myapp/
        - migrations/
        - __init__.py
        - __init__.py
        - admin.py
        - apps.py
        - models.py
        - tests.py
        - views.py
    - myproject/
        - __init__.py
        - settings.py
        - urls.py
        - asgi.py
        - wsgi.py
    - db.sqlite
    - manage.py

Рассмотрим каждый из файлов:

-  myapp/ - директория приложения

    - migrations/ - директория для хранения миграций базы данных
   
      - __init__.py - файл, указывающий на то, что директория
      является пакетом Python
      
    - __init__.py - файл, указывающий на то, что директория является
      пакетом Python
   
    - admin.py - файл для настройки административного интерфейса
    приложения
   
    - apps.py - файл для настройки приложения
   
    - models.py - файл, содержащий модели данных приложения
   
    - tests.py - файл для написания тестов приложения

    - views.py - файл, содержащий представления (views) приложения

- myproject/ - директория проекта

    - __init__.py - файл, указывающий на то, что директория является
  пакетом Python
  
    - settings.py - файл, содержащий настройки проекта
  
    - urls.py - файл, содержащий маршруты (routes) для обработки URL-адресов
  
    - asgi.py - файл для запуска ASGI-сервера (Asynchronous Server
    Gateway Interface)
  
    - wsgi.py - файл для запуска WSGI-сервера (Web Server Gateway
    Interface)
  
- db.sqlite - файл базы данных SQLite

- manage.py - файл для управления проектом Django (запуск сервера,
создание миграций и т.д.)

В процессе разработки приложения создаются ещё несколько файлов и
каталогов:

- файл маршрутов (urls.py)
- каталог для файлов шаблонов (templates/)

#### Добавление приложения в проект

После создания проекта нужно в файле *"setting.py"* нужно добавить название 
приложения в список *"INSTALLED_APPS"*.

После добавления список выглядит так:

- *INSTALLED_APPS = [*
  - *'django.contrib.admin',*
  - *'django.contrib.auth',*
  - *'django.contrib.contenttypes',*
  - *'django.contrib.sessions',*
  - *'django.contrib.messages',*
  - *'django.contrib.staticfiles',*
  - *'myapp',*
- *]*

Перечисленные в списке строки отвечают за:

- django.contrib.admin - Сайт администратора.

- django.contrib.auth - Система аутентификации.

- django.contrib.contenttypes - Структура для типов контента.

- django.contrib.sessions - Структура сеанса.

- django.contrib.messages - Фреймворк обмена сообщениями.

- django.contrib.staticfiles - Фреймворк для управления статическими
файлами.

- myapp - созданное вами приложение

#### Создание представления в приложении.

Представления в приложении называются *"view"* и для создания представления
в файле *"views.py"*, которое находится в каталоге приложения, нужно 
определить функцию.

- *from django.http import HttpResponse*

- *def index(request):*
    - *return HttpResponse("Hello, world!")*

- *def about(request):*
    - *return HttpResponse("About us")*

Функция index принимает объект request, который содержит информацию о
запросе, и возвращает объект HttpResponse, который содержит ответ сервера.
В данном случае мы просто возвращаем текст "Hello, world!".

Вторая функция будет возвращать "About us". Пара простейших представлений
созданы. Но работать они пока не будут. Необходимо настроить маршруты.

#### Настройка путей.

После создания представлений нужно указать маршруты (routes), которые 
будут связывать URL с соответствующим представлением (view) в приложении. 

Настраиваются маршруты в файле *"urls.py"*, который находится в корне проекта 
и позже еще создается в каталоге приложения.

После открытия файла *"urls.py"* в корне проекта нужно добавить маршрут 
к приложению. После выполнения код выглядит так:

- *from django.contrib import admin*
- *from django.urls import path, include*
- *urlpatterns = [*
  - *path('admin/', admin.site.urls)*
  - *path('', include('myapp.urls')),*
- *]*

Ниже показано, что делает этот код:

- Импортируется модуль admin из пакета django.contrib. С встроенной
админкой мы будем работать в рамках курса.

- Импортируется функция path и модуль include из пакета django.urls. Обе
функции нужны для формирования url адресов, на которые будет
отвечать сервер.

- Создается список urlpatterns, который будет содержать маршруты
(routes) для обработки URL-адресов.

- Добавляется маршрут для административной панели Django, который
будет обрабатывать URL-адрес, начинающийся с префикса "admin/" и
передавать управление в модуль admin.site.urls.

- Добавляется маршрут для приложения myapp, который будет
обрабатывать пустой URL-адрес и передавать управление в модуль
myapp.urls. Маршрут включается с помощью функции include.

После заполнения файла *"urls.py"* в корне проекта нужно создать файл с 
таким же названием в каталоге приложения для исключения ошибки поиска файла
*"urls.py"* в каталоге *"myapp"*.

Внутри файла *"urls.py"* в каталоге приложения нужно прописать:

- *from django.urls import path*
- *from . import views*

- *urlpatterns = [*
  - *path('', views.index, name='index'),*
  - *path('about/', views.about, name='about'),*
- *]*

Импортируем уже знакомую функцию path и файл с представлениями из
текущего каталога (импорт через точку).

В данном примере мы определяем два маршрута: первый маршрут связывает
корневой URL с представлением index, а второй маршрут связывает URL
'/about/' с представлением about.

Функция path() принимает два аргумента: первый аргумент - это URL-адрес, а
второй - это представление, которое будет обрабатывать запрос на этот URL.
Также можно задать имя маршрута с помощью параметра name.

Таким образом, настройка URL в Django позволяет определить маршруты для
обработки запросов на определенные URL и связать их с соответствующими
представлениями

Для убеждения в работе сервера повторно выполните команду 
*"python manage.py runserver"* и если при переходе по адресам 
*"http://127.0.0.1:8000/"* и *"http://127.0.0.1:8000/about/"*
Отображается все так как и запланировано в представлении и нет ошибок,
то работа проходит корректно.

#### Немного подробнее о path() и include()

Прежде чем двигаться дальше, внесём небольшое изменение в написанный
код. Разберёмся в том как работают функции path и include из пакета
django.urls.

Исправим файл myproject/urls.py. Заменим первый параметр функции path с
пустой строки на какой-нибудь текст, например на prefix:

- *from django.contrib import admin*
- *from django.urls import path, include*

- *urlpatterns = [*
  - *path('admin/', admin.site.urls),*
  - *path('prefix/', include('myapp.urls'))*
- *]*

Теперь при попытке перейти по адресу *"http://127.0.0.1:8000/"* 
получит ошибку 404

*Page not found (404)
Request Method: GET
Request URL: http://127.0.0.1:8000/
Using the URLconf defined in myproject.urls, Django tried these URL
patterns, in this order:
admin/
prefix/
The empty path didn't match any of these.*

У нас нет маршрута для обработки корневого адреса. Попробуем перейти по
адресу *"http://127.0.0.1:8000/prefix/about/"* Видим, что представление about
отработало свой код и вернула текст.

При вводе адреса в браузер сервер начинает сопоставлять введённый путь с
содержимым списка *"urlpatterns"* из *"urls.py"* проекта. Найдя совпадение, оно
отбрасывается и оставшееся часть пути передаётся в *"urls.py"* указанный 
внутри функции *"include"*. В нашем примере это *"myapp/urls.py"*. 
Он также просматривает список *"urlpatterns"* в поисках совпадений. В нашем 
примере будет вызвана функция views.about().

### Логирование в Django.

Для активации логирования сначала нужно в файле *"settings.py"*, который
находится в корне проекта, в конец файла внести следующие строки:

- *LOGGING = {*
  - *'version': 1,*
  - *'disable_existing_loggers': False,*
  - *'handlers': {*
    - *'console': {*
        - *'class': 'logging.StreamHandler',*
    - *},*
    - *'file': {*
        - *'class': 'logging.FileHandler',*
          - *'filename': '/path/to/django.log',*
    - *},*
  - *},*
  - *'loggers': {*
    - *'django': {*
      - *'handlers': ['console', 'file'],*
      - *'level': 'INFO',*
    - *},*
    - *'myapp': {*
      - *'handlers': ['console'],*
      - *'level': 'DEBUG',*
      - *'propagate': True,*
    - *},*
  - *},*
- *}*

Давайте рассмотрим каждый параметр:

- version: версия формата конфигурации логирования. В настоящее время
используется версия 1.
 
- disable_existing_loggers: если значение равно True, то все существующие
логгеры будут отключены. Если значение равно False, то существующие
логгеры будут продолжать работать.

- handlers: определяет, какие обработчики будут использоваться для
записи логов. Обработчики могут быть консольными или файловыми.

- loggers: определяет, какие логгеры будут использоваться для записи
логов. Логгеры могут быть определены для фреймворка Django или для
конкретного приложения.

Для каждого обработчика и логгера можно указать следующие параметры:

- class: класс, который будет использоваться для записи логов. В нашем
примере мы используем классы StreamHandler и FileHandler для записи
логов в консоль и файл соответственно.

- filename: путь к файлу, в который будут записываться логи. В нашем
примере мы записываем логи в файл /path/to/django.log.
Внимание! Каталог path/ и вложенный в него каталог to/ необходимо
создать самостоятельно. Либо исправьте значение на django.log, чтобы
создать файл логов в корневой директории проекта.

- level: минимальный уровень логирования, который будет записываться.
В нашем примере мы указали уровень INFO для логгера django и уровень
DEBUG для логгера myapp.

- propagate: если значение равно True, то сообщения будут передаваться
родительским логгерам. Если значение равно False, сообщения не будут
передаваться родительским логгерам.

После перезапуска сервера логирование начнёт работать в рамках Django.
Перейдите по существующим адресам. Теперь загляните в файл django.log и
сравните его содержимое с информацией в консоли.

Для внедрения логирования в приложение нужно в файл *"views.py"* в каталоге
приложения изменить код до такого состояния, как указано в примере:

- *import logging*

- *from django.http import HttpResponse*

- *logger = logging.getLogger(__name__)*

- *def index(request):*
  - *logger.info('Index page accessed')*
  - *return HttpResponse("Hello, world!")*
- *def about(request):*
  - *try:*
*# some code that might raise an exception*
    - *result = 1 / 0*
  - *except Exception as e:*
    - *logger.exception(f'Error in about page: {e}')*
    - *return HttpResponse("Oops, something went wrong.")*
  - *else:*
    - *logger.debug('About page accessed')*
    - *return HttpResponse("This is the about page.")*

В первой функции index мы просто записываем в лог информацию о том, что
страница была запрошена. Мы используем логгер *"info"*. Сообщение будет
выведено на консоль.

Во второй функции about мы используем логгер *"exception"* и *"debug"*. 
Если код выполняется без ошибок, мы записываем в лог информацию о том, что
страница была запрошена. Если происходит ошибка, мы записываем в лог
информацию об ошибке с помощью метода exception, который автоматически
добавляет трассировку стека. Затем мы возвращаем пользователю сообщение
об ошибке.

Обратите внимание, что ошибки происходят внутри приложения *"myapp"* и не
сохраняются в файле логов. Наши настройки прописывают сохранение в файл
только логов уровня приложения. 

Меняем местами параметр *"file"* так:


- *'django': {*
    - *'handlers': ['console'],*
    - *'level': 'INFO',*
- *},*
- *'myapp': {*
    - *'handlers': ['console', 'file'],*
    - *'level': 'DEBUG',*
    - *'propagate': True,*
- *},* 

Теперь логи приложения и в консоли и в фале.

#### Добавление форматирования в логи.

Как и в случае со стандартным logging из Python мы можем прописать формат
вывода сообщений. Например, такая строка добавляет вывод уровня
предупреждения и само сообщение:

*"{'format': '%(levelname)s %(message)s'}"*

Модификацию словаря LOGGER с добавлением форматированного вывода
будет выглядеть так:

- *LOGGING = {*
  - *'version': 1,*
  - *'disable_existing_loggers': False,*
  - *'formatters': {*
    - *'verbose': {*
      - *'format': '{levelname} {asctime} {module} {process} {thread}*
                    - *{message}',*
      - *'style': '{',*
    - *},*
    - *'simple': {*
      - *'format': '%(levelname)s %(message)s'*
    - *},*
  - *},*
  - *'handlers': {*
    - *'console': {*
      - *'class': 'logging.StreamHandler',*
      - *'formatter': 'verbose', - # добавлен параметр formatter*
    - *},*
    - *'file': {
      - *'class': 'logging.FileHandler',*
      - *'filename': './log/django.log',*
      - *'formatter': 'verbose', - # добавлен параметр formatter*
    - *},*
  - *},*
  - *'loggers': {*
    - *'django': {*
      - *'handlers': ['console', 'file'],*
      - *'level': 'INFO',*
    - *},*
    - *'myapp': {*
        - *'handlers': ['console', 'file'],*
        - *'level': 'DEBUG',*
        - *'propagate': True,*
    - *},*
  - *},*
- *}*

Ключ 'formatters' добавляет пару вариантов форматирования. При этом второй
вариант, simple использует классическую строку форматирования через %.

Первый вариант использует форматирование через фигурные скобки, что явно
прописано в паре *'style': '{',*.

Далее мы используем созданные ранее обработчики console и file, но
добавляем в них строку *'formatter': 'verbose',*. 
Теперь вывод логов происходит по заданному нами формату.

Освежить знания по логированию вы всегда можете на странице официальной
документации Python https://docs.python.org/3/library/logging.html
